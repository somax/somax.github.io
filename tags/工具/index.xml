<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>工具 on So&#39;Blog</title>
    <link>https://somax.me/tags/%E5%B7%A5%E5%85%B7.html</link>
    <description>Recent content in 工具 on So&#39;Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 11 Nov 2015 09:37:32 +0000</lastBuildDate>
    
	<atom:link href="https://somax.me/tags/%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Gulp挑战Grunt，背后的哲学</title>
      <link>https://somax.me/teambition/tb_56430c5c9aa4fb332ec87d72.html</link>
      <pubDate>Wed, 11 Nov 2015 09:37:32 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_56430c5c9aa4fb332ec87d72.html</guid>
      <description>这篇文章（56430c5c9aa4fb332ec87d72）是从 Teambition 迁移过来的
 原文链接： http://www.jianshu.com/p/3779f708f5d7/
 [按：网上介绍Gulp和Grunt安装使用的文章很多，甚少比较二者的思路，连官方文档都语焉不详。我在此做一个粗陋的对比，希望能提纲挈领，加深读者对这两个工具的理解。]
 做过点儿正经开发的同学都知道，构建工具必不可少。C时代的Make、Java的Ant、Ruby的Rake……没有这些工具，一遍遍地点选输入，准烦死你。
在前端和Node JS的开发中，最普及的构建工具就是Grunt。它的功能说来简单，就是管理一系列的Task。大部分的Task都是第三方的插件，安装好对应的NPM包，再loadNpmTasks就可以用了。
Grunt的配置文件Gruntfile，主要包含两部分：
配置每个Task，包括文件从哪里，到哪里去，还有一些处理的选项
自己写一些简单的Task，把第三方插件提供的Task组合起来
别看这两个事儿，轻轻松松几百行出来了。每个Task的配置，各有各的规矩，还牵扯到插件间的配合。反正我从seed库开始做新项目的时候，基本不敢改原来的Gruntfile，很多用不上的功能也搁那儿。留意了一下很多开源项目的Gruntfile，也都臃肿杂乱，好不到哪儿去。
Gruntfile维护起来那么困难，有几个原因：
配置和运行分离 程序员都知道，变量的声明和使用挨在一起，最方便理解和修改。但Gruntfile里，配置Task和调用它们的地方离得很远，极大地增加了心智负担。
每个插件做的事太多 每个Task的结果必须写到磁盘文件，另一个Task再读，损害性能倒是小事，更麻烦的是让整个过程变复杂了。 就像一个个小作坊，来料加工又返回给客户，这中间的沟通成本、出错机会都大大增加。
配置项过多 做事多了，配置项自然也多。至少输入和输出的位置得配吧。每个插件的配置规则还不尽相同。用每个插件，都得去学习一番。
Gulp应运而生。
恐怕没几个IT人不知道Unix管道的概念。前一级的输出，直接变成后一级的输入。把简单的工具组合起来，优雅地解决复杂的问题。听起来那么熟悉呢？是的，Gulp就把这种思维用在构建过程中。
Gulp基于Node JS的一个机制，叫做stream，有点类似C++中的stream。在Node中，文件访问、输入输出、HTTP连接，都是stream。Gulp的每个插件从stream中读取输入，做一些处理，再输出到stream中。
每个插件不是拿来独立使用的。相反，它专注于完成单一职责。只有把合适的插件组合起来，才能完成具体的Task。引用官方的例子，看看一个典型的Task长什么样(略有删减)：
var paths = { scripts: [&#39;client/js/**/*.coffee&#39;, &#39;!client/external/**/*.coffee&#39;] }; gulp.task(&#39;scripts&#39;, [&#39;clean&#39;], function() { // 可以依赖于其它task return gulp.src(paths.scripts) // 指定输入 .pipe(coffee()) // 环节一 .pipe(uglify()) // 环节二 .pipe(concat(&#39;all.min.js&#39;)) // 环节三 .pipe(gulp.dest(&#39;build/js&#39;)); // 指定输出 });  配置呢？不需要了。是不是行云流水，一气呵成？
那我们再回头来看看前面Grunt的几个问题，Gulp是怎么解决的：
配置和运行分离 code over configuration，直接就在调用的地方配置。
每个插件做的事太多 单一职责，依靠组合来发挥作用。就像一条自动化生产线，上一道工序的产出直接交给下一步，效率不要太高。</description>
    </item>
    
    <item>
      <title>NPM 的版本号管理命令 version</title>
      <link>https://somax.me/teambition/tb_55558ada886052772bc6fec6.html</link>
      <pubDate>Fri, 15 May 2015 05:57:46 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_55558ada886052772bc6fec6.html</guid>
      <description>这篇文章（55558ada886052772bc6fec6）是从 Teambition 迁移过来的
 利用&amp;nbsp;npm version&amp;nbsp;命令，可以自动更改 package.json 中的版本号
$ npm version [&amp;lt;newversion&amp;gt; | major | minor | patch | premajor如果项目是基于 git 管理的，运行这个命令会在 git 中用此版本号自动打一个 tag，使用&amp;nbsp;-m&amp;nbsp;参数在添加 tag 时加上注释。
$ npm version patch -m &#34;Upgrade to %s for reasons&#34;如果不需要在 git 打 tag 使用参数&amp;nbsp;--no-git-tag-version
$ npm --no-git-tag-version version patch完整文档：&amp;nbsp;https://docs.npmjs.com/cli/version</description>
    </item>
    
    <item>
      <title>gitbook 开源图书制作工具</title>
      <link>https://somax.me/teambition/tb_552cb1869c170add4f7fa78f.html</link>
      <pubDate>Tue, 14 Apr 2015 06:19:50 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_552cb1869c170add4f7fa78f.html</guid>
      <description>这篇文章（552cb1869c170add4f7fa78f）是从 Teambition 迁移过来的
 Write &amp;amp; Publish with Markdown and Git
https://www.gitbook.com

免费图书
https://www.gitbook.com/explore</description>
    </item>
    
  </channel>
</rss>