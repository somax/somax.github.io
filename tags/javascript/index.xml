<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Javascript on So&#39;Blog</title>
    <link>https://somax.me/tags/javascript/</link>
    <description>Recent content in Javascript on So&#39;Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 11 Nov 2015 09:37:32 +0000</lastBuildDate>
    
	<atom:link href="https://somax.me/tags/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Gulp挑战Grunt，背后的哲学</title>
      <link>https://somax.me/teambition/tb_56430c5c9aa4fb332ec87d72/</link>
      <pubDate>Wed, 11 Nov 2015 09:37:32 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_56430c5c9aa4fb332ec87d72/</guid>
      <description>这篇文章（56430c5c9aa4fb332ec87d72）是从 Teambition 迁移过来的
 原文链接： http://www.jianshu.com/p/3779f708f5d7/
 [按：网上介绍Gulp和Grunt安装使用的文章很多，甚少比较二者的思路，连官方文档都语焉不详。我在此做一个粗陋的对比，希望能提纲挈领，加深读者对这两个工具的理解。]
 做过点儿正经开发的同学都知道，构建工具必不可少。C时代的Make、Java的Ant、Ruby的Rake……没有这些工具，一遍遍地点选输入，准烦死你。
在前端和Node JS的开发中，最普及的构建工具就是Grunt。它的功能说来简单，就是管理一系列的Task。大部分的Task都是第三方的插件，安装好对应的NPM包，再loadNpmTasks就可以用了。
Grunt的配置文件Gruntfile，主要包含两部分：
配置每个Task，包括文件从哪里，到哪里去，还有一些处理的选项
自己写一些简单的Task，把第三方插件提供的Task组合起来
别看这两个事儿，轻轻松松几百行出来了。每个Task的配置，各有各的规矩，还牵扯到插件间的配合。反正我从seed库开始做新项目的时候，基本不敢改原来的Gruntfile，很多用不上的功能也搁那儿。留意了一下很多开源项目的Gruntfile，也都臃肿杂乱，好不到哪儿去。
Gruntfile维护起来那么困难，有几个原因：
配置和运行分离 程序员都知道，变量的声明和使用挨在一起，最方便理解和修改。但Gruntfile里，配置Task和调用它们的地方离得很远，极大地增加了心智负担。
每个插件做的事太多 每个Task的结果必须写到磁盘文件，另一个Task再读，损害性能倒是小事，更麻烦的是让整个过程变复杂了。 就像一个个小作坊，来料加工又返回给客户，这中间的沟通成本、出错机会都大大增加。
配置项过多 做事多了，配置项自然也多。至少输入和输出的位置得配吧。每个插件的配置规则还不尽相同。用每个插件，都得去学习一番。
Gulp应运而生。
恐怕没几个IT人不知道Unix管道的概念。前一级的输出，直接变成后一级的输入。把简单的工具组合起来，优雅地解决复杂的问题。听起来那么熟悉呢？是的，Gulp就把这种思维用在构建过程中。
Gulp基于Node JS的一个机制，叫做stream，有点类似C++中的stream。在Node中，文件访问、输入输出、HTTP连接，都是stream。Gulp的每个插件从stream中读取输入，做一些处理，再输出到stream中。
每个插件不是拿来独立使用的。相反，它专注于完成单一职责。只有把合适的插件组合起来，才能完成具体的Task。引用官方的例子，看看一个典型的Task长什么样(略有删减)：
var paths = { scripts: [&#39;client/js/**/*.coffee&#39;, &#39;!client/external/**/*.coffee&#39;] }; gulp.task(&#39;scripts&#39;, [&#39;clean&#39;], function() { // 可以依赖于其它task return gulp.src(paths.scripts) // 指定输入 .pipe(coffee()) // 环节一 .pipe(uglify()) // 环节二 .pipe(concat(&#39;all.min.js&#39;)) // 环节三 .pipe(gulp.dest(&#39;build/js&#39;)); // 指定输出 });  配置呢？不需要了。是不是行云流水，一气呵成？
那我们再回头来看看前面Grunt的几个问题，Gulp是怎么解决的：
配置和运行分离 code over configuration，直接就在调用的地方配置。
每个插件做的事太多 单一职责，依靠组合来发挥作用。就像一条自动化生产线，上一道工序的产出直接交给下一步，效率不要太高。</description>
    </item>
    
    <item>
      <title>AngularJs 代码风格指南</title>
      <link>https://somax.me/teambition/tb_5632e0496fec47d05396a864/</link>
      <pubDate>Fri, 30 Oct 2015 03:13:13 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5632e0496fec47d05396a864/</guid>
      <description>这篇文章（5632e0496fec47d05396a864）是从 Teambition 迁移过来的
 Controller 的别名 使用这种风格编写代码，可以增强可读性，便于维护及减少出错的可能
app.js (function(global) { &amp;#39;use strict&amp;#39;; var __appname = &amp;#39;myApp&amp;#39; angular.module(__appname, [&amp;#39;myModule&amp;#39;]) .config(__config) .run(__run); function __config($somethingInject) { // ...  } __config.$inject = [&amp;#39;$somethingInject&amp;#39;]; function __run($somethingInject){ //...  } __run.$inject = [&amp;#39;$somethingInject&amp;#39;] // 启动 App  angular.element(document).ready(function() { // { strictDi:true} 为可选参数  // 在 AngularJs 1.3 版本以后，使用静态注入(strictDi)可以提高性能  angular.bootstrap(document, [__appname],{ strictDi:true}); }); })();  myModule.js (function(global) { &amp;#39;use strict&amp;#39;; angular.module(&amp;#39;myModule&amp;#39;, [&amp;#39;subModule&amp;#39;]) .</description>
    </item>
    
    <item>
      <title>$http 统一资源封装方案</title>
      <link>https://somax.me/teambition/tb_5620b0c5079a12ff3c4b2fe0/</link>
      <pubDate>Fri, 16 Oct 2015 08:09:41 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5620b0c5079a12ff3c4b2fe0/</guid>
      <description>这篇文章（5620b0c5079a12ff3c4b2fe0）是从 Teambition 迁移过来的
 封装 (function () { &amp;#39;use strict&amp;#39;; angular.module(&amp;#39;UM.comm&amp;#39;,[]) .factory(&amp;#39;Resources&amp;#39;,Resources); /** * 统一资源生成器 * @param {$http} $http angular 内置方法 */ function Resources($http){ function ResourceConstructor(options){ var _uri = options.uri; var _isArray = options.isArray; var _res = _isArray ? [] : {}; Object.defineProperties( _res, { &amp;#39;setData&amp;#39; : { value : _defineSetDataFunction(_isArray) }, &amp;#39;get&amp;#39; : { value : _get }, &amp;#39;add&amp;#39; : { value : _add }, &amp;#39;delete&amp;#39; : { value : _delete } } ); function _defineSetDataFunction(_isArray) { if (_isArray) { return function (_data) { _res.</description>
    </item>
    
    <item>
      <title>Angular 视频精选</title>
      <link>https://somax.me/teambition/tb_55f83d08a415a44077c73551/</link>
      <pubDate>Tue, 15 Sep 2015 15:45:12 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_55f83d08a415a44077c73551/</guid>
      <description>这篇文章（55f83d08a415a44077c73551）是从 Teambition 迁移过来的
 ng-conf 2015 The New Router Creating Container Components with Web Components and Angular
附带一个国外视频网站下载工具：http://en.savefrom.net</description>
    </item>
    
    <item>
      <title>HTML5存储之战 －－ localStorage vs. IndexedDB vs. Web SQL</title>
      <link>https://somax.me/teambition/tb_55aafb28f85b738a17cdb67d/</link>
      <pubDate>Sun, 19 Jul 2015 01:19:36 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_55aafb28f85b738a17cdb67d/</guid>
      <description>这篇文章（55aafb28f85b738a17cdb67d）是从 Teambition 迁移过来的
 2012-11-08 当前，在本地浏览器有三种方式可以比cookies更永久和大量地存储数据： 1. Web Storage 2. Indexed Database API 3. Web SQL Database
这些名字看起来都差不多，但实现方式是不一样的。接下来会说说，它们能够做什么、优点和缺点、目前我最喜欢的是什么。尽管我的意见会随着技术的不断成熟而改变。
这几种技术都采用了相同的保护数据访问的方式（例如，javascript只能访问当前域名下的数据）。这些保护方式都很好，并且没有区别，下面我将不再做详细说明。
Web Storage Web存储（web storage），特别是本地存储（local storage）部分，是一个简单的键值存储系统（key/value persistence system）。
优点： * 十分简单的API，主流浏览器的新版本都已经获得支持。
缺点： * 不支持查询语言，模式（schemas），跟平常调用数据库不一样。对于大型数据的组织不能很好的进行扩展。 * 不支持事务安全。如果应用在运行，我想晚上就不能睡个安稳觉了，因为随时可能出现竞争条件（race condition）并出现数据污染的危机。
Index Database API IndexedDB是基于简单的平面文件（flat-file）数据库，采用了分层的键值存储（key/value persistence）和基本的索引。
优点： * 如果你熟悉NoSQL，这是再适合不过了。
缺点： * 还没获得大部分浏览器的支持。 * 不支持SQL，但未来可能会有支持SQL的模块。
Web SQL Database Web SQL是基于浏览器中嵌入的sqlite。我已经断断续续地使用sqlite有几年了。刚开始由于它的名字和所采用的架构（只是一个平面文件（flat-file)数据库）而看不起它（原谅我的浅薄）。经过深入钻研，我发现它是一个非常稳定的平台，只要你能容忍它的限制，很适合产品的使用。其实它的限制也不是很大（我想存储个1G应该问题不大），继承了平面文件（flat-file）数据库的优点（高并发性）但缺少一些特性（存储过程（stored procs）和其它一些高端数据库特性）。
优点： * 快速和功能丰富的sql实现（除了select/insert/update/delete，还能使用joins、inner selects等）。
缺点： * Chrome和基于webkit的浏览器（safari等）支持，但Firefox和IE不支持。 * 那个该死的W3C工作组已经坚持这个标准有一段时间了，他们很久前说过至少会有两个对该标准的独立实现，但到目前为止只有一个，因为每个人都使用sqlite。
我倒希望标准工作组能够考虑一下sqlite的特殊性并改进一下标准－－这个已经在公共域名上了，对每个人都可用，没有附加条款。Sqlite非常适合浏览器，它的限制不是问题。一次只有一个用户使用浏览器，没有并发问题。在简单没有管理的数据库中，没人需要高端数据库的一些特性。我想这是为什么Android和iOS都使用sqlite来存储。
总结 如果需要部署在移动平台，Web SQL是没有异议的。如果是桌面环境并使用Chrome或Safari作为你的浏览器，Web SQL也是合适的。当前我不会在大型应用中使用其他两种标准。</description>
    </item>
    
    <item>
      <title>JS 时间格式化函数</title>
      <link>https://somax.me/teambition/tb_558152efdfd682891f387002/</link>
      <pubDate>Wed, 17 Jun 2015 10:58:55 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_558152efdfd682891f387002/</guid>
      <description>这篇文章（558152efdfd682891f387002）是从 Teambition 迁移过来的
 输入毫秒，返回 以 “xx天xx小时xx分xx秒xx毫秒&amp;rdquo; 格式的字符串。 function timeFormat(v) { var r; var S =1000, M = 60 * S, H = 60 * M, D = H * 24;
 function _parse(v,m,n){ return parseInt(v%m/n); } function ms(t) { return _result(_parse(t,S,1),&#39;毫秒&#39;); } function s(t){ return _result(_parse(t,M,S),&#39;秒&#39;); } function m(t){ return _result(_parse(t,H,M),&#39;分钟&#39;); } function h(t){ return _result(_parse(t,D,H),&#39;小时&#39;); } function d (t) { return _result(_parse(t,Infinity,D),&#39;天&#39;); } function _result(v,u){ return (v) ?</description>
    </item>
    
    <item>
      <title>connect源码分析--基础架构</title>
      <link>https://somax.me/teambition/tb_5565a8acf5468b8006ed7d8f/</link>
      <pubDate>Wed, 27 May 2015 11:21:16 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5565a8acf5468b8006ed7d8f/</guid>
      <description>这篇文章（5565a8acf5468b8006ed7d8f）是从 Teambition 迁移过来的
 connect是TJ tx给node.js社区贡献的一个热门的web基础框架。TJ的另一力作express框架便是在它基础之上构建的。与express不同，connect更加短小精悍，是一个偏向基础设施的框架。
正如名字所表达的一样，connect框架做的事情很简单，就是把一系列的组件连接到一起，然后让http的请求依次流过这些组件。这些被connect串联起来的组件被称为中间件（middlewire）。在connect中，http请求的处理流程被划分成一个个小片段，每一个小片段代表一项处理任务（如：请求body的解析，session的维护等），由一个中间件负责，前后片段之间靠request，response等对象传递中间数据。connect框架对这些处理细节并不关心，只知道将请求从一个中间件导向下一个中间件。connect的核心代码非常精简，加上注释，也就只有寥寥200来行代码。
https://cnodejs.org/topic/4fb79b0e06f43b56112b292c</description>
    </item>
    
    <item>
      <title>Javascript 中的策略模式</title>
      <link>https://somax.me/teambition/tb_5565a0e9e68ba27e066b6f99/</link>
      <pubDate>Wed, 27 May 2015 10:48:09 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5565a0e9e68ba27e066b6f99/</guid>
      <description>这篇文章（5565a0e9e68ba27e066b6f99）是从 Teambition 迁移过来的
 我喜欢策略设计模式。我尽可能多的试着去使用它。究其本质，策略模式使用委托去解耦使用它们的算法类。
这样做有几个好处。他可以防止使用大条件语句来决定哪些算法用于特定类型的对象。将关注点分离开来，因此降低了客户端的复杂度，同时还可以促进子类化的组成。它提高了模块化和可测性。每一个算法都可以单独测试。每一个客户端都可以模拟算法。任意的客户端都能使用任何算法。他们可以互调。就像乐高积木一样。
为了实现策略模式，通常有两个参与者：
该策略的对象，封装了算法。
客户端（上下文）对象，以即插即用的方式能使用任何策略。
这里介绍了我在Javascrip里，怎样使用策略模式，在混乱无序的环境中怎样使用它将库拆成小插件，以及即插即用包的。
http://www.oschina.net/translate/strategy-design-pattern-in-javascript</description>
    </item>
    
    <item>
      <title>数据绑定的革命 Object.observe()</title>
      <link>https://somax.me/teambition/tb_553057b2775a02951cdca69d/</link>
      <pubDate>Fri, 17 Apr 2015 00:45:38 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_553057b2775a02951cdca69d/</guid>
      <description>这篇文章（553057b2775a02951cdca69d）是从 Teambition 迁移过来的
 Data-binding Revolutions with Object.observe()IntroductionA revolution is coming. There’s a new addition to JavaScript that’s going to change&amp;nbsp;everything&amp;nbsp;you think you know about data-binding. It’s also going to change how many of your MVC libraries approach observing models for edits and updates. Are you ready for some sweet performance boosts to apps that care about property observation?
Okay. Okay. Without further delay, I’m happy to announce&amp;nbsp;Object.observe()&amp;nbsp;has landed in&amp;nbsp;Chrome 36&amp;nbsp;stable.</description>
    </item>
    
  </channel>
</rss>