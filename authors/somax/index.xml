<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Somax on So&#39;Blog</title>
    <link>https://somax.me/authors/somax.html</link>
    <description>Recent content in Somax on So&#39;Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Wed, 23 May 2018 17:29:49 +0800</lastBuildDate>
    
	<atom:link href="https://somax.me/authors/somax/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title> 从 Teambition 迁移过来的文档</title>
      <link>https://somax.me/teambition.html</link>
      <pubDate>Wed, 23 May 2018 17:29:49 +0800</pubDate>
      
      <guid>https://somax.me/teambition.html</guid>
      <description> 这里的文章都是从 Teambition 迁移过来的，迁移说明在这里。
 </description>
    </item>
    
    <item>
      <title>（译）如何用视觉类比来思考 - 图表</title>
      <link>https://somax.me/memo/how-to-think-visually.html</link>
      <pubDate>Mon, 02 Jul 2018 09:52:51 +0800</pubDate>
      
      <guid>https://somax.me/memo/how-to-think-visually.html</guid>
      <description>这是我目前看到最好的一篇关于数据可视化图表的文章，所以花点时间翻译了一下，并在此转发。
 水平有限，翻译过程得到了 谷歌翻译 的帮助，如有不妥请在文章底部留言。
原文：https://blog.adioma.com/how-to-think-visually-using-visual-analogies-infographic/
原作者：Anna Vital
 视觉学习者是那些用图像思考1并用语言与其他人交流那张图片的人。 世界上约有60％ 2的人是视觉学习者。 （我是他们中的一员，我猜，既然你正在阅读这篇文章，你也是一样，我们中的很多人还不知道我们是视觉学习者，因为学校迫使我们大部分时间在基于文本学习。）
那么，你如何通过图像和文字与我们交谈？ 使用普遍存在的『视觉符号』和『类比』。 下图是它们的排列组合。
视觉交流的关键在于寻找普遍存在并且无需解释的视觉符号。
大多数认知科学研究探讨了我们如何看待事物，但很少研究我们如何『理解』我们所看到的。
『理解』是对你可视化效果的终极考验。 那么，你如何让人们明白？ 展示一些大家熟悉的『 类比』。如果你对可视化并不了解，可是却选择正确的『类比』，那么你已经成功了一大半了。 这就是专业设计师所做的 - 没有其他可以替代『类比』。
你如何选择正确的『类比』？ 在下面的表格中，我从抽象到具象整理了『类比』的形式。 我将它们按形状相似性分组。 目标是可以让你快速在你的『信息』上『试用』。 随着时间的推移，你将能够在你的脑海中做到这一切。 但现在这是一条捷径。
让我们从简单和抽象开始。
图表，图形和示意图 我们从圆形开始。 （宇宙中的大部分东西都是圆的！）
   图示 说明      1. 饼图( Pie Chart)： 最受欢迎同时也最受质疑。 正如Edward Tufte所说，“&amp;hellip;&amp;hellip;比一张饼图差的东西只有『很多』”。 现代信息图的父亲Otto Neurath也拒绝使用更多语义图标的饼图。 饼图分为两部分时最好使用：我吃过的派和我离开的派。 有了两个部分，你仍然可以轻松地比较切片的大小 - 这在两个以上的情况下变得困难，因此受到了批评。 一旦你有三个或更多的部分，你有一个比较问题 - 我们的眼睛不习惯比较一个圆的部分。 我们也不擅长比较不同的饼图。 当然饼图仍然有一些适合的场景，但很少。 *例如：我在 “七十亿人做什么” 图表以及 启动资金如何显示创始人股权比例 中使用它*。    2.</description>
    </item>
    
    <item>
      <title>用 SSH 建立安全隧道</title>
      <link>https://somax.me/memo/ssh-tunneling.html</link>
      <pubDate>Thu, 14 Jun 2018 15:19:06 +0800</pubDate>
      
      <guid>https://somax.me/memo/ssh-tunneling.html</guid>
      <description>参考：https://forwardhq.com/help/ssh-tunneling-how-to
 使用 SSH 能够安全地访问远程服务器，同时 SSH 也有一些鲜为人知的特点。其中一个很厉害功能就是隧道。
隧道允许你将远程服务器上的一个端口转发到本地服务器上的一个端口。这对于web开发者尤其有用，它允许你在本地Web服务器和互联网之间创建一个隧道，在互联网的任何地方都可以通过这个隧道访问您的本地应用程序或网站。
这篇文章介绍如何利用 SSH Tunneling 突破防火墙建立远程链接。
大致流程如下：
{ 私有服务器 } ---- 发起 ssh tunneling ---&amp;gt; { 公开服务器 } &amp;lt;----- { 客户机 }  前置条件  你需要有一个可公开访问的服务器，可以是任何一种服务器只要有安装有 SSH 服务。
 你还需要设置SSH服务器的配置文件，添加 GatewayPorts yes。
 配置文件通常是位于/etc/ssh/sshd_config，可能取决于您的系统的不同。修改后，一定要重新启动SSH服务，运行 sudo service sshd restart
 为了保持连接防止超时断开，还需要在配置中添加 ClientAliveInterval 60
 ClientAliveInterval 指定了服务器端向客户端请求消息的时间间隔, 默认是0，不发送。而ClientAliveInterval 60表示每 60 秒发送一次，然后客户端响应，这样就保持长连接了。
另外ClientAliveCountMax 使用默认值 3 即可。ClientAliveCountMax 表示服务器发出请求后客户端没有响应的次数达到一定值，就自动断开。
  修改配置  先查看当前配置
cd /etc/ssh sudo grep &amp;#34;ClientAlive&amp;#34; sshd_config #ClientAliveInterval 0 #ClientAliveCountMax 3 备份配置</description>
    </item>
    
    <item>
      <title>Typora 使用小技巧</title>
      <link>https://somax.me/memo/typora-tips.html</link>
      <pubDate>Sun, 10 Jun 2018 14:36:06 +0800</pubDate>
      
      <guid>https://somax.me/memo/typora-tips.html</guid>
      <description>Typora 是一款非常好用跨平台 Markdown 编辑器。和很多类似的软件一样使用 Web 技术开发，并使用 Electron 封装成桌面应用，目前 beta 版可以免费下载使用，写这篇博客的时版本是 0.9.9.16.2。
Typora 新版本增加了很多功能，这里记录一下个人在使用过程中的一些偏好设置与小技巧（基于 MacOS）。
命令行启动 很多时候工作流程会使用 git 命令对文档进行版本管理，为了快速的在命令行启动 Typora，我通过添加别名t来快速启动 Typora。在 ~/.bash_profile 中添加 alias t=&amp;quot;open -a typora&amp;quot;，执行source ~/.bash_profile后，就可以在命令行中运行 t path/to/filename.md 以快速打开并开始编辑文件。
新版 Typora 支持了文件夹模式，所以可以运行t path 打开整个文件夹，或者 用t . 打开当前文件夹。
，偏好设置 按 Command + , 打开偏好设置面板。
 偏好设置可以根据个人喜好的设置，这里列出了一些我自己的喜好，也许在今后的深入使用过程中会更改这些设置。
 自定义主题  可以在偏好设置面板点击『打开主题文件夹』查看所有样式文件，详细说明查看官方文档：https://support.typora.io/Add-Custom-CSS/
 我比较喜欢 github 主题，但我希望改变一下背景颜色，让眼睛更舒适，在主题文件夹新建 github.user.css文件，添加如下代码：
body{ background-color: #f3f2ee; } @media print { body{ background-color: #fff; } } 然后再新增 base.user.css 文件，在里面添加一些自定义的样式，这个文件是针对所有主题都起作用的。</description>
    </item>
    
    <item>
      <title>将 Teambition 分享迁移到 hugo</title>
      <link>https://somax.me/memo/export-from-teambition.html</link>
      <pubDate>Wed, 23 May 2018 23:06:25 +0800</pubDate>
      
      <guid>https://somax.me/memo/export-from-teambition.html</guid>
      <description>Teambition 是一个非常好的团队协作工具，公司内部一直使用它做项目管理和知识分享的平台。
经过几年的积累，在公司 TB 知识管理项目中已经发布了三百来条分享记录（自己都没想到有这么多了），其中有很多是可以公开的，所以利用之前研究 TB API 的项目的基础上，完成了批量导出并自动生成 hugo 格式文档的工具 somax/teambition-sync 。
虽然 hugo 生成 300 篇文章只需要 2250ms，不过还是需要人工筛选一下，后续会慢慢（也许很快）上传到 这里。</description>
    </item>
    
    <item>
      <title>建站笔记 - 将网站托管到 Github</title>
      <link>https://somax.me/memo/host-on-github.html</link>
      <pubDate>Mon, 21 May 2018 16:41:58 +0800</pubDate>
      
      <guid>https://somax.me/memo/host-on-github.html</guid>
      <description>有很多使用 github pages 功能免费发布网站的教程，也可以直接看 官方文档，就不再赘述了。
github 设定 有一些注意事项这里提一下，根据 github 的规定，使用 &amp;lt;用户名&amp;gt;.github.io 作为项目名称，就可以通过 &amp;lt;用户名&amp;gt;.github.io 这个域名访问到网站，所以我的是就是 somax.github.io。
hugo 渲染页面默认会输出到 public 目录，想了个方案来管理源文件和最终静态网站文件：
 在项目中建立 master 及 src 两个分支，master 分支用来放最终静态网站文件，而 src 分支存放源文件 在 src 分支上，添加 public 目录到 .gitignore 以便提交源码时忽略它 然后在 public 目录中重新 git init 并存放 master 分支  这样就很方便了，源码在主目录操作，hugo 命令渲染好在进入 public 提交静态页面代码。
域名设置 想要 .IO 或者 .ME 的域名，找了一下国内域名供应商视乎没有提供。最后在 godaddy.com 购买了 somax.me，第一年 6 折，2年共 ￥150.99。
购买成功后，进入 DNS 管理界面进行 DNS 配置：
   类型 名称 值 TTL     A @ 185.</description>
    </item>
    
    <item>
      <title>建站笔记 - 使用 hugo 建立我的博客</title>
      <link>https://somax.me/memo/building-soblog-with-hugo.html</link>
      <pubDate>Mon, 21 May 2018 14:01:10 +0800</pubDate>
      
      <guid>https://somax.me/memo/building-soblog-with-hugo.html</guid>
      <description>这是 开篇 之后的第一篇博客，记录一下建立这个博客网站的过程应该是个不错的选择。
 前言 其实很久之前就有看到别人使用 Github Pages + jekyll 来免费搭建自己的博客网站，不过最近由于工作的原因接触 go 语言的项目越来越多，所以特意查了一下 Go 语言相关的建站工具，发现了 hugo 这个项目。 就毫不犹豫的（其实还是纠结了一下）选择了 hugo。原因主要是 开源，跨平台，安装简单，渲染速度快！官方自称：&amp;rdquo;The world’s fastest framework for building websites&amp;ldquo;
使用 Hugo 建立网站 过程中参考了官方文档，还有个老兄建立了中文版的网站 http://gohugo.org 也给了很大帮助。
不过作为学习总结，还是记录一下自己的操作过程。
安装 Hugo hugo 官网访问很慢，还是直接 github release 下载比较快。根据操作系统选择合适版本下载即可（由于 Go语言的特性，天生跨平台，可以选择 ARM 版本来安装到树莓派上玩耍），具体过程就略了。
新建站点 按照 快速手册 一步步下来，基本上没什么问题。
 hugo 安装完成一定要选择一个 Theme（或者自建&amp;ndash;如果觉得自己可以的话），并且根据 Theme 的说明配置好 config.toml 文件，否则可能只能看到不完整的网站。
 https://themes.gohugo.io/minimo/ 看上去不错，比较简洁，很适合做日志型网站。
文档 一定要先看一遍，避免走弯路（因为我已经走了🕺）。
修改配置  从 minimo theme 的 exampleSite 目录中复制 config.</description>
    </item>
    
    <item>
      <title>开篇</title>
      <link>https://somax.me/post/first.html</link>
      <pubDate>Sun, 20 May 2018 09:52:51 +0800</pubDate>
      
      <guid>https://somax.me/post/first.html</guid>
      <description>Finally!! 🎉 为了鼓励儿子利用博客做学习笔记（儿子的博客)，拖延了很久之后，自己的博客终于上线了！一起加油吧儿子💪！
经过了精心的挑选，最后选择了 hugo 作为我的博客静态网站生成工具，主要原因还是 go 语言的那些特性带来的优势。后面的文章我会记录一下用 hugo 建立博客的过程。
第一篇，就这样。</description>
    </item>
    
    <item>
      <title>k8s 学习笔记</title>
      <link>https://somax.me/teambition/tb_5afd7ecef496bb0018d2e144.html</link>
      <pubDate>Thu, 17 May 2018 13:08:30 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5afd7ecef496bb0018d2e144.html</guid>
      <description>这篇文章（5afd7ecef496bb0018d2e144）是从 Teambition 迁移过来的
 安装 kubectl 启用命令自动补完 Zsh  官方文档： https://kubernetes.io/docs/tasks/tools/install-kubectl/
 If you are using zsh edit the ~/.zshrc file and add the following code to enable kubectl autocompletion:
if [ $commands[kubectl] ]; then source &amp;lt;(kubectl completion zsh) fi Or when using Oh-My-Zsh, edit the ~/.zshrc file and update the plugins= line to include the kubectl plugin.
source &amp;lt;(kubectl completion zsh) 安装 minikube  官方文档：https://kubernetes.io/docs/tasks/tools/install-minikube/#install-minikube
因为网络的原因，国内安装要用阿里改过的版本，参考：
 https://yq.</description>
    </item>
    
    <item>
      <title>内部并联网络打通配置方法</title>
      <link>https://somax.me/teambition/tb_5afd4b7f8fb0b000189366aa.html</link>
      <pubDate>Thu, 17 May 2018 09:29:35 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5afd4b7f8fb0b000189366aa.html</guid>
      <description>这篇文章（5afd4b7f8fb0b000189366aa）是从 Teambition 迁移过来的
 网络拓扑  [192.168.126.0] / \ [wan: 192.168.126.200] [wan: 192.168.126.233] TP-Link | | MiRoute Pro [lan: 192.168.123.0] [lan: 192.168.120.0]  目的 将 192.168.123.0网段与 192.168.120.0 网段相互打通。
配置方案 在两个子网路由器上分别设置静态路由，192.168.123.0 网段访问 192.168.120.0 配置路由指向 192.168.126.233 ，同理 192.168.120.0 网段访问 192.168.123.0 网段则配置路由指向 192.168.126.200
具体步骤 配置 TP-Link 路由器  添加静态路由规则：
 登录控制界面，选择 『传输控制』 - 『路由设置』-『静态路由』
 点选『新增』
   规则名称: to120 目的地址: 192.168.120.0 子网掩码: 255.255.255.0 下一跳: 192.168.126.233 出接口: WAN1  ​</description>
    </item>
    
    <item>
      <title>Gitlab 备份到 Minio 的配置方法</title>
      <link>https://somax.me/teambition/tb_5af07ebce98ef93186181ac0.html</link>
      <pubDate>Mon, 07 May 2018 16:28:44 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5af07ebce98ef93186181ac0.html</guid>
      <description>这篇文章（5af07ebce98ef93186181ac0）是从 Teambition 迁移过来的
  进入 Gitlab 容器操作：docker exec -it &amp;lt;container-id&amp;gt; bash
 编辑 /etc/gitlab/gitlab.rb
  gitlab_rails[&amp;#39;backup_upload_connection&amp;#39;] = { &amp;#39;provider&amp;#39; =&amp;gt; &amp;#39;AWS&amp;#39;, &amp;#39;aws_access_key_id&amp;#39; =&amp;gt; &amp;#39;xxxxxxxxxxxxx&amp;#39;, &amp;#39;aws_secret_access_key&amp;#39; =&amp;gt; &amp;#39;xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx&amp;#39;, &amp;#39;endpoint&amp;#39; =&amp;gt; &amp;#39;http://minio-server-host:9000&amp;#39;, &amp;#39;path_style&amp;#39; =&amp;gt; true } gitlab_rails[&amp;#39;backup_upload_remote_directory&amp;#39;] = &amp;#39;bucket-name&amp;#39; 注意事项：
 必须设置 &#39;path_style&#39; =&amp;gt; true aws_access_key_id 和 aws_secret_access_key 对应的是 Minio 的 Access Key 与 Secret Key，注意这两个值必须足够复杂，否则可能会导致 403 错误   重新配置 gitlab：gitlab-ctl reconfigure，配置正确的话会自动重启 Gitlab
 运行备份命令：gitlab-rake gitlab:backup:create
  如果反馈中有 Uploading backup archive to remote storage mybucket .</description>
    </item>
    
    <item>
      <title>容器中运行的 Gitlab 备份方法</title>
      <link>https://somax.me/teambition/tb_5ae1f9b051c9c600182a40aa.html</link>
      <pubDate>Thu, 26 Apr 2018 16:09:20 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5ae1f9b051c9c600182a40aa.html</guid>
      <description>  这篇文章（5ae1f9b051c9c600182a40aa）是从 Teambition 迁移过来的
 原文： https://docs.gitlab.com/omnibus/settings/backups.html#creating-backups-for-gitlab-instances-in-docker-containers
备份 Gitlab 数据 docker exec -t &amp;lt;your container name&amp;gt; gitlab-rake gitlab:backup:create 备份配置文件 docker exec -t &amp;lt;your container name&amp;gt; /bin/sh -c &amp;#39;umask 0077; tar cfz /secret/gitlab/backups/$(date &amp;#34;+etc-gitlab-%s.tgz&amp;#34;) -C / etc/gitlab&amp;#39;</description>
    </item>
    
    <item>
      <title>使用容器部署 OpenVPN</title>
      <link>https://somax.me/teambition/tb_5ad5ff7346021671da825337.html</link>
      <pubDate>Tue, 17 Apr 2018 14:06:43 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5ad5ff7346021671da825337.html</guid>
      <description>这篇文章（5ad5ff7346021671da825337）是从 Teambition 迁移过来的
部署过程使用了开源项目：kylemanna/docker-openvpn，详细文档请访问 https://github.com/kylemanna/docker-openvpn
  为数据卷选个名字存放到环境变量 $OVPN_DATA，建议使用 ovpn-data- 前缀来方便识别。在下面的示例中请替换 example。  OVPN_DATA=&amp;#34;ovpn-data-example&amp;#34;  初始化 $OVPN_DATA 容器，这个容器将用来存放配置文件与证书。 初始化过程中会提示输入密码来保护证书。下面的示例中请使用合适的域名或 IP 地址替换 VPN.SERVERNAME.COM。  docker volume create --name $OVPN_DATA docker run -v $OVPN_DATA:/etc/openvpn --rm kylemanna/openvpn ovpn_genconfig -u udp://VPN.SERVERNAME.COM docker run -v $OVPN_DATA:/etc/openvpn --rm -it kylemanna/openvpn ovpn_initpki  启动容器  docker run -v $OVPN_DATA:/etc/openvpn -d -p 1194:1194/udp --cap-add=NET_ADMIN kylemanna/openvpn  生成客户端证书（无密码）  docker run -v $OVPN_DATA:/etc/openvpn --rm -it kylemanna/openvpn easyrsa build-client-full CLIENTNAME nopass  导出客户端配置文件（包含证书）  docker run -v $OVPN_DATA:/etc/openvpn --rm kylemanna/openvpn ovpn_getclient CLIENTNAME &amp;gt; CLIENTNAME.</description>
    </item>
    
    <item>
      <title>Rancher 中 RethinkDB 集群节点无法启动故障排除</title>
      <link>https://somax.me/teambition/tb_5a0fe53a4da5ce0928d5f28d.html</link>
      <pubDate>Sat, 18 Nov 2017 07:46:02 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5a0fe53a4da5ce0928d5f28d.html</guid>
      <description>这篇文章（5a0fe53a4da5ce0928d5f28d）是从 Teambition 迁移过来的
 故障描述  之前 RethinkDB 按照 1 + 3 的模式集群部署成功，每个节点分别部署在不同的 host 上。由于某种未知原因，其中一台 host 在 Rancher 中失联，在连接恢复后该 host 上的 RethinkDB 就一直无法正常启动。  解决过程  首先检查了 RethinkDB 节点的日志，发现一切正常，但 Rancher UI 上的状态却一直显示不正常 在 RethinkDB 管理界面上有一瞬间看到了第三个节点加入，然后忽然又没了，推断该节点容器在被 Rancher 一直重启 检查 Rancher 基础服务，发现 Rancher/HealthCheck 处于不正常状态，尝试重启、删除都没有成功。 远程进入容器所在主机，用 docker 命令 kill，竟然没用 🤷‍♂️ Rancher 中停止主机，再删，还是没有用 🤷‍♀️ 要不重启主机？等下&amp;hellip;&amp;hellip; 还是先试试重启 docker 吧&amp;hellip;  解决方案  重启 Docker sudo systemctl restart docker  成功👌，Rancher 会帮我们把余下的事情做掉，所有的容器不出意外都会自动起来（事实上的确没出意外）。来再检查一下，HealthCheck ✅， RethinkDB ✅，搞定！</description>
    </item>
    
    <item>
      <title>用 sh 脚本生成 Niginx Vhost 配置文件</title>
      <link>https://somax.me/teambition/tb_59005034c621c6c81bf78e70.html</link>
      <pubDate>Wed, 26 Apr 2017 07:45:56 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_59005034c621c6c81bf78e70.html</guid>
      <description>这篇文章（59005034c621c6c81bf78e70）是从 Teambition 迁移过来的
 touch ngxcfg.sh $$ chmod +x ngxcfg.sh 脚本代码如下：
#!/bin/bash # MaXiaojun  help() { echo &amp;#34;Generate vhost configuration file for Nginx&amp;#34; echo &amp;#34;Usage:&amp;#34; echo &amp;#34; ngxcfg &amp;#34; echo &amp;#34; ngxcfg -r www.jkr3.com https://192.168.123.123:8080&amp;#34; echo &amp;#34; -h Help&amp;#34; echo &amp;#34; -r Generate redirect config file.&amp;#34; echo &amp;#34; -f Force overwrite config file.&amp;#34; } # get options while getopts &amp;#34;:hrfv&amp;#34; optname &amp;#34;$@&amp;#34; do case &amp;#34;$optname&amp;#34; in &amp;#34;v&amp;#34;) echo v0.</description>
    </item>
    
    <item>
      <title>NodeJS监测module是被直接执行还是被require</title>
      <link>https://somax.me/teambition/tb_56652c34bb9364076f95e8a2.html</link>
      <pubDate>Mon, 07 Dec 2015 06:50:28 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_56652c34bb9364076f95e8a2.html</guid>
      <description> 这篇文章（56652c34bb9364076f95e8a2）是从 Teambition 迁移过来的
 通常用在模块可以直接运行，也可以被其他项目引用的情况下
// Check if run directly if (require.main === module) { console.log(&#39;run directly...&#39;); main(); } else { console.log(&#39;require on module....&#39;); module.exports = servermon; }  </description>
    </item>
    
    <item>
      <title>Mocha test-runner with gulp</title>
      <link>https://somax.me/teambition/tb_56643084ce2cd4cc6659b45c.html</link>
      <pubDate>Sun, 06 Dec 2015 12:56:36 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_56643084ce2cd4cc6659b45c.html</guid>
      <description>这篇文章（56643084ce2cd4cc6659b45c）是从 Teambition 迁移过来的
 Passing shared module in all tests // npm install gulp gulp-mocha  var gulp = require(&amp;#39;gulp&amp;#39;); var mocha = require(&amp;#39;gulp-mocha&amp;#39;); gulp.task(&amp;#39;default&amp;#39;, function() { return gulp.src([&amp;#39;test/test-*.js&amp;#39;], { read: false }) .pipe(mocha({ reporter: &amp;#39;spec&amp;#39;, globals: { should: require(&amp;#39;should&amp;#39;) } })); });  Running mocha tests when files change // npm install gulp gulp-mocha gulp-util  var gulp = require(&amp;#39;gulp&amp;#39;); var mocha = require(&amp;#39;gulp-mocha&amp;#39;); var gutil = require(&amp;#39;gulp-util&amp;#39;); gulp.</description>
    </item>
    
    <item>
      <title>ShadowSock 快速上手</title>
      <link>https://somax.me/teambition/tb_5645566510638ccf2327a70e.html</link>
      <pubDate>Fri, 13 Nov 2015 03:17:57 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5645566510638ccf2327a70e.html</guid>
      <description>这篇文章（5645566510638ccf2327a70e）是从 Teambition 迁移过来的
 Server Install Debian / Ubuntu:
apt-get install python-pip pip install shadowsocks  CentOS:
yum install python-setuptools &amp;amp;&amp;amp; easy_install pip pip install shadowsocks  Windows:
See [Install Server on Windows]
Usage ssserver -p 443 -k password -m aes-256-cfb  To run in the background:
sudo ssserver -p 443 -k password -m aes-256-cfb --user nobody -d start  To stop:
sudo ssserver -d stop  To check the log:</description>
    </item>
    
    <item>
      <title>如何在Git项目中添加空目录</title>
      <link>https://somax.me/teambition/tb_5638441326ad9cd2130a33ec.html</link>
      <pubDate>Tue, 03 Nov 2015 05:20:19 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5638441326ad9cd2130a33ec.html</guid>
      <description>这篇文章（5638441326ad9cd2130a33ec）是从 Teambition 迁移过来的
 在要添加的目录下新建 .gitignore 文件，文件中添加以下信息：
# Ignore everything in this directory * # Except this file !.gitignore 更新 20160429：这里可以找到针对各种开发语言的 .gitignore 模板：github.com/github/gitignore</description>
    </item>
    
    <item>
      <title>AngularJs 代码风格指南</title>
      <link>https://somax.me/teambition/tb_5632e0496fec47d05396a864.html</link>
      <pubDate>Fri, 30 Oct 2015 03:13:13 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5632e0496fec47d05396a864.html</guid>
      <description>这篇文章（5632e0496fec47d05396a864）是从 Teambition 迁移过来的
 Controller 的别名 使用这种风格编写代码，可以增强可读性，便于维护及减少出错的可能
app.js (function(global) { &amp;#39;use strict&amp;#39;; var __appname = &amp;#39;myApp&amp;#39; angular.module(__appname, [&amp;#39;myModule&amp;#39;]) .config(__config) .run(__run); function __config($somethingInject) { // ...  } __config.$inject = [&amp;#39;$somethingInject&amp;#39;]; function __run($somethingInject){ //...  } __run.$inject = [&amp;#39;$somethingInject&amp;#39;] // 启动 App  angular.element(document).ready(function() { // { strictDi:true} 为可选参数  // 在 AngularJs 1.3 版本以后，使用静态注入(strictDi)可以提高性能  angular.bootstrap(document, [__appname],{ strictDi:true}); }); })();  myModule.js (function(global) { &amp;#39;use strict&amp;#39;; angular.module(&amp;#39;myModule&amp;#39;, [&amp;#39;subModule&amp;#39;]) .</description>
    </item>
    
    <item>
      <title>$http 统一资源封装方案</title>
      <link>https://somax.me/teambition/tb_5620b0c5079a12ff3c4b2fe0.html</link>
      <pubDate>Fri, 16 Oct 2015 08:09:41 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5620b0c5079a12ff3c4b2fe0.html</guid>
      <description>这篇文章（5620b0c5079a12ff3c4b2fe0）是从 Teambition 迁移过来的
 封装 (function () { &amp;#39;use strict&amp;#39;; angular.module(&amp;#39;UM.comm&amp;#39;,[]) .factory(&amp;#39;Resources&amp;#39;,Resources); /** * 统一资源生成器 * @param {$http} $http angular 内置方法 */ function Resources($http){ function ResourceConstructor(options){ var _uri = options.uri; var _isArray = options.isArray; var _res = _isArray ? [] : {}; Object.defineProperties( _res, { &amp;#39;setData&amp;#39; : { value : _defineSetDataFunction(_isArray) }, &amp;#39;get&amp;#39; : { value : _get }, &amp;#39;add&amp;#39; : { value : _add }, &amp;#39;delete&amp;#39; : { value : _delete } } ); function _defineSetDataFunction(_isArray) { if (_isArray) { return function (_data) { _res.</description>
    </item>
    
    <item>
      <title>Nginx 源码安装</title>
      <link>https://somax.me/teambition/tb_56189a31e7a72b1965b6df12.html</link>
      <pubDate>Sat, 10 Oct 2015 04:55:13 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_56189a31e7a72b1965b6df12.html</guid>
      <description>这篇文章（56189a31e7a72b1965b6df12）是从 Teambition 迁移过来的
 安装准备 首先由于nginx的一些模块依赖一些lib库，所以在安装nginx之前，必须先安装这些lib库，这些依赖库主要有g++、gcc、openssl-devel、pcre-devel和zlib-devel ，执行如下命令安装。
$ yum install gcc-c++ pcre pcre-devel zlib zlib-devel openssl openssl-devel  安装Nginx # 安装之前，最好检查一下是否已经安装有nginx $ find -name nginx # 如果系统已经通过 yum 安装了nginx，那么就先卸载 $ yum remove nginx # 从官网下载最新版的nginx $ wget http://nginx.org/download/nginx-1.9.3.tar.gz # 解压nginx压缩包 $ tar -zxvf nginx-1.9.3.tar.gz # 这时进入nginx-1.9.3目录 $ cd nginx-1.9.3 # --prefix参数指定nginx安装的目录, 加上 --with-http_ssl_module 使支持https，加上--with-http_v2_module 支持 http/2（1.9.5 以上） # 如果安装过程中说系统没有安装 Openssl，重新安装`yum install openssl openssl--devel `， 也可以加上--with-openssl=/usr/local/openssl-0.x.x 参数 $ ./configure --prefix=/usr/local/nginx --with-http_ssl_module --with-http_v2_module # 或者加载更多模块 # .</description>
    </item>
    
    <item>
      <title>HTTP协议状态码详解（HTTP Status Code）</title>
      <link>https://somax.me/teambition/tb_56174a257da60c8f224df82b.html</link>
      <pubDate>Fri, 09 Oct 2015 05:01:25 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_56174a257da60c8f224df82b.html</guid>
      <description>这篇文章（56174a257da60c8f224df82b）是从 Teambition 迁移过来的
 常用代码 |代码 | 说明 | |-|-| |200| 服务器成功返回网页 | |404| 请求的网页不存在 | |401|（未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。| |500| 服务器内部错误 |
1XX 临时响应  表示临时响应并需要请求者继续执行操作的状态代码
    代码 说明     100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。   101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。    2xx 成功  表示成功处理了请求的状态代码
    代码 说明     200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。   201 （已创建） 请求成功并且服务器创建了新的资源。   202 （已接受） 服务器已接受请求，但尚未处理。   203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。   204 （无内容） 服务器成功处理了请求，但没有返回任何内容。   205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。   206 （部分内容） 服务器成功处理了部分 GET 请求。    3xx 重定向  表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。</description>
    </item>
    
    <item>
      <title>Rsync 在非标ssh端口(22) 中用法</title>
      <link>https://somax.me/teambition/tb_560e1356d908de0d2585d058.html</link>
      <pubDate>Fri, 02 Oct 2015 05:17:10 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_560e1356d908de0d2585d058.html</guid>
      <description>  这篇文章（560e1356d908de0d2585d058）是从 Teambition 迁移过来的
 问题 使用rsync拷贝文件，有个主机的ssh端口使用的并非标准端口(22)，查看rsync的文档，看到有种带有端口的用法：
rsync [OPTION]... SRC [SRC]... rsync://[USER@]HOST[:PORT]/DEST 但使用会返回错误：
rsync: server sent &amp;#34;SSH-2.0-OpenSSH_5.3&amp;#34; rather than greeting rsync error: error starting client-server protocol (code 5) at main.c(1534) [sender=3.0.9] 解决 开始以为是客户端服务器rsync版本不兼容，后来发现对于非标准ssh端口(22)的使用方法是使用-e参数：
rsync [OPTION]... -e &amp;#34;ssh -p 2222&amp;#34; SRC [SRC]... [USER@]HOST[:PORT]/DEST</description>
    </item>
    
    <item>
      <title>iptables 配置范例</title>
      <link>https://somax.me/teambition/tb_560b7b14262a98424070c7a7.html</link>
      <pubDate>Wed, 30 Sep 2015 06:03:00 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_560b7b14262a98424070c7a7.html</guid>
      <description>这篇文章（560b7b14262a98424070c7a7）是从 Teambition 迁移过来的
 linux 系统中使用 iptables 配置防火墙
修改文件：/etc/sysconfig/iptables
*filter :INPUT ACCEPT [0:0] :FORWARD ACCEPT [0:0] :OUTPUT ACCEPT [0:0] -A INPUT -s 127.0.0.1/32 -d 127.0.0.1/32 -j ACCEPT -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT -A INPUT -p tcp -m tcp --dport 22 -j ACCEPT -A INPUT -p tcp -m tcp --dport 80 -j ACCEPT -A INPUT -p tcp -m tcp --dport 443 -j ACCEPT -A INPUT -p tcp -m tcp --dport 21 -j ACCEPT -A INPUT -p tcp -m tcp --dport 20 -j ACCEPT -A INPUT -p tcp -m tcp --dport 8080 -j ACCEPT -A INPUT -j REJECT --reject-with icmp-port-unreachable -A FORWARD -j REJECT --reject-with icmp-port-unreachable -A OUTPUT -j ACCEPT COMMIT 重新启动 service iptables restart</description>
    </item>
    
    <item>
      <title>3D模型转换与烘培贴图</title>
      <link>https://somax.me/teambition/tb_55dfc2bb44b37a5b19c7a35d.html</link>
      <pubDate>Fri, 28 Aug 2015 02:08:59 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_55dfc2bb44b37a5b19c7a35d.html</guid>
      <description>这篇文章（55dfc2bb44b37a5b19c7a35d）是从 Teambition 迁移过来的
 工具：
SketchUp 2014Blender 2.74流程：
从 SketchUp 中导出 dae文件 （选项：除了仅“导出所选集合”外，不用勾选任何其他选项）在 blender 中导入 dae文件在 blender 中清理模型中的无用物体为每一个物体展开UV选择Cycles渲染 &amp;gt;&amp;nbsp;添加基本材质烘培光影贴图 &amp;gt; 保存渲染贴图切换回Blender渲染 &amp;gt; 为物体添加材质导出 3ds 文件格式导出模型注意事项：
模型中不能存在镂空，如有镂空，需要用线切分模型（也就是说可以是 “ C ” 形，但不能是 “ O ” 形）。只有在Blender渲染模式下定义贴图，才能在导出的模型中携带贴图路径信息导出3ds模型中贴图引用的文件名不能超过7个字符</description>
    </item>
    
    <item>
      <title>参数排序混合算法及性能测试</title>
      <link>https://somax.me/teambition/tb_55d80d51dcc2954b0a0159e5.html</link>
      <pubDate>Sat, 22 Aug 2015 05:49:05 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_55d80d51dcc2954b0a0159e5.html</guid>
      <description> 这篇文章（55d80d51dcc2954b0a0159e5）是从 Teambition 迁移过来的
 JavaScript:
console.time(&amp;#39;time&amp;#39;) for(var i=0;i&amp;lt;10000;i++){ var obj = {abc:1,efg:2,aaa:3,qwe:52,ojj:98,gjd:836}; var result = Object.keys(obj) .sort(function(a,b){return a &amp;gt; b}) .map(function(a){return a+obj[a]}) .join(&amp;#39;&amp;#39;); //console.log(result); } console.timeEnd(&amp;#39;time&amp;#39;)  使用 .reduce()方法
console.time(&amp;#39;time&amp;#39;) for(var i=0;i&amp;lt;10000;i++){ var obj = {abc:1,efg:2,aaa:3,qwe:52,ojj:98,gjd:836}; var result = Object.keys(obj) .sort(function(a,b){return a &amp;gt; b}) .reduce(function(a,b,i){return a+(i==1?obj[a]:&amp;#39;&amp;#39;)+b+obj[b]}); //console.log(result); } console.timeEnd(&amp;#39;time&amp;#39;) </description>
    </item>
    
    <item>
      <title>字符数字混合排序</title>
      <link>https://somax.me/teambition/tb_559a4842e736a6e544c0bd67.html</link>
      <pubDate>Mon, 06 Jul 2015 09:20:02 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_559a4842e736a6e544c0bd67.html</guid>
      <description> 这篇文章（559a4842e736a6e544c0bd67）是从 Teambition 迁移过来的
 字符数字混合情况下，如何获得按数字正确排序?
这里以 angularjs 的自定义排序作为例子，我使用了正则表达式把所有数字的区段找到，然后前面填充0。
js:
/** * 设备列表 自定义排序 * * 通过对数字补‘0’来获得正确的排序 * L12-3 -&amp;gt; L0012-0003 * 这里预估序号最大不会超过 9999，所有采用4位填充。 */ $scope.orderByDeviceNo = function(_device) { var _deviceNo = _device.deviceno; _deviceNo = _deviceNo &amp;amp;&amp;amp; _deviceNo.replace(/(\d+)/g, function($1) { return paddingZero($1, 4); }); return _deviceNo; }; function paddingZero(num, n) { return (Array(n).join(0) + num).slice(-n); }  html:
&amp;lt;li ng-repeat=&amp;#34;device in deviceList | orderBy:orderByDeviceNo&amp;#34; &amp;gt;</description>
    </item>
    
    <item>
      <title>理解Linux系统负荷</title>
      <link>https://somax.me/teambition/tb_558232c63dd208c010934638.html</link>
      <pubDate>Thu, 18 Jun 2015 02:53:58 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_558232c63dd208c010934638.html</guid>
      <description>这篇文章（558232c63dd208c010934638）是从 Teambition 迁移过来的
 查看系统负荷 在Linux系统中，使用uptime命令查看（w命令和top命令也行）。（另外，它们在苹果公司的Mac电脑上也适用。）
 10:39 up 1 day, 21:03, 4 users, load averages: 2.99 2.94 2.92  这行信息的后半部分，显示&amp;rdquo;load average&amp;rdquo;，它的意思是&amp;rdquo;系统的平均负荷&amp;rdquo;，分别是1分钟、5分钟、15分钟内系统的平均负荷。
如果你继续看手册，它还会告诉你，当CPU完全空闲的时候，平均负荷为0；当CPU工作量饱和的时候，平均负荷为1。 那么很显然，&amp;rdquo;load average&amp;rdquo;的值越低，比如等于0.2或0.3，就说明电脑的工作量越小，系统负荷比较轻。
一个类比 判断系统负荷是否过重，必须理解load average的真正含义。 假设最简单的情况，你的电脑只有一个CPU，所有的运算都必须由这个CPU来完成。 我们把这个CPU想象成一座大桥，桥上只有一根车道，所有车辆都必须从这根车道上通过。 系统负荷为0，意味着大桥上一辆车也没有。 系统负荷为0.5，意味着大桥一半的路段有车。 系统负荷为1.0，意味着大桥的所有路段都有车，也就是说大桥已经&amp;rdquo;满&amp;rdquo;了。但是必须注意的是，直到此时大桥还是能顺畅通行的。 系统负荷为1.7，意味着车辆太多了，大桥已经被占满了（100%），后面等着上桥的车辆为桥面车辆的70%。以此类推，系统负荷2.0，意味着等待上桥的车辆与桥面的车辆一样多；系统负荷3.0，意味着等待上桥的车辆是桥面车辆的2倍。总之，当系统负荷大于1，后面的车辆就必须等待了；系统负荷越大，过桥就必须等得越久。
CPU的系统负荷，基本上等同于上面的类比。大桥的通行能力，就是CPU的最大工作量；桥梁上的车辆，就是一个个等待CPU处理的进程（process）。
如果CPU每分钟最多处理100个进程，那么系统负荷0.2，意味着CPU在这1分钟里只处理20个进程；系统负荷1.0，意味着CPU在这1分钟里正好处理100个进程；系统负荷1.7，意味着除了CPU正在处理的100个进程以外，还有70个进程正排队等着CPU处理。
为了电脑顺畅运行，系统负荷最好不要超过1.0，这样就没有进程需要等待了，所有进程都能第一时间得到处理。很显然，1.0是一个关键值，超过这个值，系统就不在最佳状态了，你要动手干预了。
系统负荷的经验法则 1.0是系统负荷的理想值吗？ 不一定，系统管理员往往会留一点余地，当这个值达到0.7，就应当引起注意了。经验法则是这样的： 当系统负荷持续大于0.7，你必须开始调查了，问题出在哪里，防止情况恶化。 当系统负荷持续大于1.0，你必须动手寻找解决办法，把这个值降下来。 当系统负荷达到5.0，就表明你的系统有很严重的问题，长时间没有响应，或者接近死机了。你不应该让系统达到这个值。
多处理器 如果你的电脑装了2个CPU，会发生什么情况呢？ 2个CPU，意味着电脑的处理能力翻了一倍。
所以，2个CPU表明系统负荷可以达到2.0，此时每个CPU都达到100%的工作量。推广开来，n个CPU的电脑，可接受的系统负荷最大为n.0。
多核处理器 芯片厂商往往在一个CPU内部，包含多个CPU核心，这被称为多核CPU。 在系统负荷方面，多核CPU与多CPU效果类似，所以考虑系统负荷的时候，必须考虑这台电脑有几个CPU、每个CPU有几个核心。然后，把系统负荷除以总的核心数，只要每个核心的负荷不超过1.0，就表明电脑正常运行。
怎么知道电脑有多少个CPU核心呢？
cat /proc/cpuinfo命令，可以查看CPU信息。grep -c &#39;model name&#39; /proc/cpuinfo命令，直接返回CPU的总核心数。
最佳观察时长 最后一个问题，&amp;rdquo;load average&amp;rdquo;一共返回三个平均值&amp;mdash;-1分钟系统负荷、5分钟系统负荷，15分钟系统负荷，&amp;mdash;-应该参考哪个值？ 如果只有1分钟的系统负荷大于1.0，其他两个时间段都小于1.0，这表明只是暂时现象，问题不大。 如果15分钟内，平均系统负荷大于1.0（调整CPU核心数之后），表明问题持续存在，不是暂时现象。所以，你应该主要观察&amp;rdquo;15分钟系统负荷&amp;rdquo;，将它作为电脑正常运行的指标。</description>
    </item>
    
    <item>
      <title>JS 时间格式化函数</title>
      <link>https://somax.me/teambition/tb_558152efdfd682891f387002.html</link>
      <pubDate>Wed, 17 Jun 2015 10:58:55 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_558152efdfd682891f387002.html</guid>
      <description> 这篇文章（558152efdfd682891f387002）是从 Teambition 迁移过来的
 输入毫秒，返回 以 “xx天xx小时xx分xx秒xx毫秒&amp;rdquo; 格式的字符串。
function timeFormat(v) { var r; var S =1000, M = 60 * S, H = 60 * M, D = H * 24; function _parse(v,m,n){ return parseInt(v%m/n); } function ms(t) { return _result(_parse(t,S,1),&amp;#39;毫秒&amp;#39;); } function s(t){ return _result(_parse(t,M,S),&amp;#39;秒&amp;#39;); } function m(t){ return _result(_parse(t,H,M),&amp;#39;分钟&amp;#39;); } function h(t){ return _result(_parse(t,D,H),&amp;#39;小时&amp;#39;); } function d (t) { return _result(_parse(t,Infinity,D),&amp;#39;天&amp;#39;); } function _result(v,u){ return (v) ? v + &amp;#39; &amp;#39; + u + &amp;#39; &amp;#39; : &amp;#39;&amp;#39;; } return d(v) + h(v) + m(v) + s(v) + ms(v) ; }; </description>
    </item>
    
    <item>
      <title>Git 基础 - 撤消操作</title>
      <link>https://somax.me/teambition/tb_55725a70de2b610a3a774d29.html</link>
      <pubDate>Sat, 06 Jun 2015 02:26:56 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_55725a70de2b610a3a774d29.html</guid>
      <description>这篇文章（55725a70de2b610a3a774d29）是从 Teambition 迁移过来的
 撤消操作 任何时候，你都有可能需要撤消刚才所做的某些操作。接下来，我们会介绍一些基本的撤消操作相关的命令。请注意，有些撤销操作是不可逆的，所以请务必谨慎小心，一旦失误，就有可能丢失部分工作成果。
修改最后一次提交 有时候我们提交完了才发现漏掉了几个文件没有加，或者提交信息写错了。想要撤消刚才的提交操作，可以使用 &amp;ndash;amend 选项重新提交： $ git commit &amp;ndash;amend
此命令将使用当前的暂存区域快照提交。如果刚才提交完没有作任何改动，直接运行此命令的话，相当于有机会重新编辑提交说明，但将要提交的文件快照和之前的一样。
启动文本编辑器后，会看到上次提交时的说明，编辑它确认没问题后保存退出，就会使用新的提交说明覆盖刚才失误的提交。
如果刚才提交时忘了暂存某些修改，可以先补上暂存操作，然后再运行 --amend 提交：
$ git commit -m &#39;initial commit&#39; $ git add forgotten_file $ git commit --amend  上面的三条命令最终只是产生一个提交，第二个提交命令修正了第一个的提交内容。
摘自官方电子书 中文版</description>
    </item>
    
    <item>
      <title>写出好的 commit message</title>
      <link>https://somax.me/teambition/tb_5560695d85e5a3fc64c6ab00.html</link>
      <pubDate>Sat, 23 May 2015 11:49:49 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_5560695d85e5a3fc64c6ab00.html</guid>
      <description>这篇文章（5560695d85e5a3fc64c6ab00）是从 Teambition 迁移过来的
 为什么要关注提交信息  加快 Reviewing Code 的过程 帮助我们写好 release note 5年后帮你快速想起来某个分支，tag 或者 commit 增加了什么功能，改变了哪些代码 让其他的开发者在运行 git blame 的时候想跪谢 总之一个好的提交信息，会帮助你提高项目的整体质量  基本要求  第一行应该少于50个字。 随后是一个空行 第一行题目也可以写成：Fix issue #8976 喜欢用 vim 的哥们把下面这行代码加入 .vimrc 文件中，来检查拼写和自动折行 autocmd Filetype gitcommit setlocal spell textwidth=72 永远不在 git commit 上增加 -m &amp;lt;msg&amp;gt; 或 --message=&amp;lt;msg&amp;gt; 参数，而单独写提交信息 一个不好的例子 git commit -m &amp;quot;Fix login bug&amp;quot;  一个推荐的 commit message 应该是这样：
Redirect user to the requested page after login https://trello.</description>
    </item>
    
    <item>
      <title>git简介</title>
      <link>https://somax.me/teambition/tb_55265335879013c64ac090a2.html</link>
      <pubDate>Thu, 09 Apr 2015 10:23:49 +0000</pubDate>
      
      <guid>https://somax.me/teambition/tb_55265335879013c64ac090a2.html</guid>
      <description>这篇文章（55265335879013c64ac090a2）是从 Teambition 迁移过来的
 更新 (20160429)：最好的Git 电子书 https://git-scm.com/book/ （在线或下载）
什么是 Git GIT不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。
Git vs SVN  Git 是分布式的，SVN不是 SVN 必须连接服务器才能提交变更； Git 在本地有完整版本库的 “clone”,允许离线提交变更和管理分支，然后push到远程库 GIT把内容按元数据方式存储，而SVN是按文件 Git会在本地存储所有东西，包括标签，分支，版本记录 SVN只在本地存储一个工作副本。 GIT分支和SVN的分支不同 SVN中分支就是版本库中的另外的一个目录； GIT的分支可以从同一个工作目录下快速的在几个分支间切换。 GIT没有一个全局的版本号，而SVN有 SVN里使用容易阅读的数字版本号，Git使用SHA-1来唯一的标识一个代码快照 GIT的内容完整性要优于SVN GIT的内容存储使用的是SHA-1哈希算法,确保在遇到磁盘故障和网络问题时降低对版本库的破坏。  Internet上开放的git仓库  国外：gitHub、gitLab … 国内：coding、gitcafe …  私有git  gitLabCE： http://git.jkr3.com   限内部访问，自行注册，注意：确认邮件99%可能会进垃圾邮件
 客户端  “建议学习命令方式”，熟悉之后非常快捷，mac或linux中可以使用自带 git 命令，通过 git help 获得帮助。
windows系统可以选择tortoiseGit，适合原来使用tortoiseSVN的用户，有中文语言包
  http://git-scm.com/downloads http://git-scm.com/downloads/guis https://code.google.com/p/tortoisegit/  Git的基本流程和使用方法 这里只介绍命令方式，在线试玩： GitTryIt
 初始化 git init 查看状态 git status 添加文件 git add README.</description>
    </item>
    
  </channel>
</rss>